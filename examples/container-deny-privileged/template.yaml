apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  creationTimestamp: null
  name: containerdenyprivileged
spec:
  crd:
    spec:
      names:
        kind: ContainerDenyPrivileged
  targets:
  - libs:
    - |
      package lib.core

      default is_gatekeeper = false

      is_gatekeeper {
        has_field(input, "review")
        has_field(input.review, "object")
      }

      resource = input.review.object {
        is_gatekeeper
      }

      resource = input {
        not is_gatekeeper
      }

      format(msg) = msg {
        not is_gatekeeper
      }

      format(msg) = {"msg": msg} {
        is_gatekeeper
      }

      apiVersion = resource.apiVersion
      name = resource.metadata.name
      kind = resource.kind
      labels = resource.metadata.labels
      annotations = resource.metadata.annotations

      has_field(obj, field) {
        not object.get(obj, field, "N_DEFINED") == "N_DEFINED"
      }
    - |
      package lib.workloads

      import data.lib.core

      pods[pod] {
        core.kind = "StatefulSet"
        pod = core.resource.spec.template
      }

      pods[pod] {
        core.kind = "DaemonSet"
        pod = core.resource.spec.template
      }

      pods[pod] {
        core.kind = "Deployment"
        pod = core.resource.spec.template
      }

      pods[pod] {
        core.kind = "Pod"
        pod = core.resource
      }

      pod_containers(pod) = all_containers {
        keys = {"containers", "initContainers"}
        all_containers = [c | keys[k]; c = pod.spec[k][_]]
      }

      containers[container] {
        pods[pod]
        all_containers = pod_containers(pod)
        container = all_containers[_]
      }

      containers[container] {
        all_containers = pod_containers(core.resource)
        container = all_containers[_]
      }
    - |
      package lib.security

      dropped_capability(container, cap) {
        container.securityContext.capabilities.drop[_] == cap
      }

      added_capability(container, cap) {
        container.securityContext.capabilities.add[_] == cap
      }

      dropped_capability(psp, cap) {
        psp.spec.capabilities.drop[_] == cap
      }

      added_capability(psp, cap) {
        psp.spec.capabilities.add[_] == cap
      }
    rego: |
      package container_deny_privileged

      import data.lib.core
      import data.lib.workloads
      import data.lib.security

      violation[msg] {
          workloads.containers[container]
          is_privileged(container)

          msg = core.format(sprintf("The Container %s in the %s %s is privileged", [container.name, core.kind, core.name]))
      }

      is_privileged(container) {
        container.securityContext.privileged
      }

      is_privileged(container) {
        security.added_capability(container, "CAP_SYS_ADMIN")
      }
    target: admission.k8s.gatekeeper.sh
status: {}
